# persistence-context-basic.md

## 개요
영속성 컨텍스트는 JPA가 엔티티(Entity)를 효율적으로 관리하기 위해 만들어둔 "엔티티 보관소" 같은 공간입니다.
개발자는 엔티티를 직접 SQL로 다루는 대신, 영속성 컨텍스트에 엔티티를 올려두고 JPA가 DB 반영을 관리하게 됩니다.

## 정의
- 영속성 컨텍스트(Persistence Context)
  - 엔티티 객체를 저장하고, 변경을 추적하고, DB 반영 타이밍을 조절하는 관리 공간입니다.
- 영속 상태(Managed)
  - 엔티티가 영속성 컨텍스트에 의해 관리되는 상태입니다.

## 핵심 개념
- 1차 캐시 느낌
  - 같은 트랜잭션(같은 작업 범위) 안에서 이미 조회한 엔티티는 다시 조회할 때 DB를 바로 치지 않고, 컨텍스트에서 먼저 찾을 수 있습니다.
- 동일성 보장
  - 같은 식별자(id)의 엔티티를 같은 컨텍스트에서 조회하면, 같은 객체(같은 인스턴스)로 다룬다는 감각이 생깁니다.
- 변경 감지(Dirty Checking)
  - 영속 상태 엔티티의 필드가 바뀌면, JPA가 "변경됨"을 감지해 둡니다.
- 쓰기 지연(모아두고 한 번에)
  - persist 같은 작업을 해도 즉시 DB에 반영되는 게 아니라, 컨텍스트가 작업을 모아두었다가 트랜잭션 커밋 시점에 DB에 반영합니다.
- 트랜잭션과 같이 간다
  - 영속성 컨텍스트는 보통 트랜잭션 범위에서 의미가 커집니다.
  - 커밋되면 반영, 롤백되면 반영되지 않음, 이 흐름이 기본입니다.

## 동작 방식
영속성 컨텍스트는 크게 3가지를 합니다.
1) 엔티티를 보관한다(조회 재사용, 동일성 유지)
2) 엔티티 변경을 추적한다(변경 감지)
3) DB 반영을 조절한다(쓰기 지연, 커밋 시 반영)

## 전체 흐름
[요청 시작]
- 서비스 로직에서 엔티티를 조회하거나 생성합니다.

[컨텍스트에 엔티티가 올라감]
- 조회하면 엔티티가 컨텍스트에 들어옵니다.
- 저장(persist)하면 저장 대상이 컨텍스트에 들어옵니다.

[로직 진행 중 변경 발생]
- 엔티티 값을 바꾸면, 컨텍스트가 변경을 추적합니다.

[트랜잭션 종료 시점]
- commit
  - 컨텍스트가 모아둔 변경을 DB에 반영합니다.
- rollback
  - 이번 트랜잭션에서 한 변경은 DB에 반영되지 않습니다.

## 실무 포인트
- "바로 DB에 반영되지 않는다"를 항상 염두에 둡니다.
  - persist 했다고 즉시 insert가 나간다고 생각하면 혼란이 생깁니다.
- 같은 트랜잭션 안에서는 조회 재사용과 동일성 개념이 중요합니다.
  - 같은 id를 여러 번 조회해도 같은 객체로 다루는 느낌이 생깁니다.
- 변경 감지 때문에 update를 직접 호출하지 않아도 반영되는 케이스가 많습니다.
  - 이 동작을 모르면 "왜 update 쿼리가 나갔지?" 같은 디버깅 포인트가 생깁니다.
- 엔티티는 공유해서 쓰는 객체가 아닙니다.
  - 보통 트랜잭션 범위에서 안전하게 다루는 모델이라고 생각하는 게 좋습니다.

## 용어 정리
| 용어 | 뜻 |
| --- | --- |
| 영속성 컨텍스트 | 엔티티를 보관하고 변경을 추적하며 DB 반영을 조절하는 공간 |
| 영속 상태 | 엔티티가 컨텍스트에 의해 관리되는 상태 |
| 1차 캐시 | 같은 범위에서 엔티티를 재사용하는 성격 |
| 변경 감지 | 엔티티 값 변경을 추적해 커밋 때 update로 반영하는 성격 |
| 쓰기 지연 | SQL을 즉시 보내지 않고 모았다가 커밋 때 반영하는 성격 |

## 질문
- persist 했는데 바로 insert가 안 나가는 이유를 내 말로 설명해볼 수 있나요?
- 같은 트랜잭션에서 같은 id를 두 번 조회하면 어떤 일이 생기나요?
- update를 호출하지 않았는데 update 쿼리가 나가는 상황은 어떤 메커니즘일까요?
- 롤백하면 영속성 컨텍스트에서 했던 변경은 어떻게 되는 걸까요?
