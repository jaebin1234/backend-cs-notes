# persistence-context-functions-basic.md

## 개요
영속성 컨텍스트는 엔티티 객체를 “편하고 안전하게” 관리하려고 만든 공간입니다.
그냥 저장소가 아니라, 조회 최적화, 동일성 보장, SQL을 모아서 처리, 변경 감지까지 담당합니다.

## 정의
- 영속성 컨텍스트
  - 엔티티를 보관하고 관리하는 공간입니다.
  - 내부에 1차 캐시(Map 형태)와 쓰기 지연 저장소 같은 구조를 가지고 있습니다.
- 식별자(@Id)
  - 영속성 컨텍스트가 엔티티를 구분하는 기준입니다.
  - 캐시의 key 역할을 합니다.

## 핵심 개념
- 영속성 컨텍스트의 대표 기능 4가지
  1) 1차 캐시
  2) 객체 동일성 보장
  3) 쓰기 지연 저장소(모아두고 반영)
  4) 변경 감지(Dirty Checking)와 flush

## 동작 방식

### 1) 1차 캐시
영속성 컨텍스트 내부에는 캐시 저장소가 있고, Map 구조로 관리됩니다.

[구조 느낌]
- key: 엔티티의 식별자 값(@Id)
- value: 엔티티 객체

[저장 흐름]
- persist(entity)를 호출하면 엔티티 객체가 1차 캐시에 들어갑니다.

[조회 흐름]
- find(Entity, id)를 호출하면
  - 먼저 1차 캐시에 id가 있는지 확인합니다.
  - 없으면 DB에 select를 하고, 결과를 1차 캐시에 저장한 뒤 반환합니다.
  - 있으면 DB를 안 가고 1차 캐시에서 바로 반환합니다.

[효과]
- DB 조회 횟수 감소
- 같은 트랜잭션 범위에서 조회가 빨라짐

### 2) 객체 동일성 보장
같은 영속성 컨텍스트 안에서 같은 id를 조회하면 같은 객체(같은 인스턴스)로 반환되는 성질이 있습니다.

[흐름]
- memo1 = find(Memo, 1)
- memo2 = find(Memo, 1)
- memo1 == memo2 가 true가 될 수 있는 이유가 여기서 나옵니다.

[효과]
- “DB row 1개당 객체 1개” 느낌으로 관리됨
- 엔티티를 다룰 때 혼란이 줄어듭니다

### 3) 쓰기 지연 저장소
insert/update/delete 같은 변경 SQL을 바로 DB에 쏘지 않고 모아두는 공간이 있습니다.

[흐름]
- persist를 여러 번 호출해도
  - 그 순간 바로 insert가 DB로 나가는 게 아니라
  - 쓰기 지연 저장소에 쌓입니다.
- 트랜잭션 커밋 시점에 한 번에 DB로 반영됩니다.

[효과]
- 쿼리를 한 번에 처리해서 성능적으로 유리한 상황이 생깁니다.
- 트랜잭션 단위로 “변경을 묶어서 처리”하는 감각이 생깁니다.

### 4) flush와 변경 감지(Dirty Checking)
영속성 컨텍스트는 엔티티를 저장할 때 “최초 상태”도 같이 들고 있습니다.
그리고 flush 시점에 “현재 상태”와 “최초 상태”를 비교합니다.

[변경 감지 흐름]
1) 엔티티를 조회해서 영속 상태로 만든다
2) 엔티티 값을 변경한다(setter 등)
3) 커밋 시점에 flush가 일어나면
4) 최초 상태와 현재 상태를 비교해서
5) 바뀐 게 있으면 update SQL을 생성하고 DB에 반영합니다

[포인트]
- JPA에는 보통 em.update 같은 호출이 없습니다.
- update는 “직접 호출”이 아니라 “변경 감지 결과”로 만들어집니다.

[flush 정리]
- flush는 영속성 컨텍스트의 변경 내용을 DB에 반영하는 동작입니다.
- 보통 커밋 직전에 자동으로 일어나지만, 직접 호출할 수도 있습니다.
- insert/update/delete 같은 변경 반영은 트랜잭션이 필요합니다.

## 전체 흐름
1) 엔티티 저장/조회가 발생하면 엔티티는 1차 캐시에 들어갑니다.
2) 같은 id 재조회는 DB가 아니라 1차 캐시에서 처리될 수 있습니다.
3) 저장/삭제 같은 SQL은 즉시 나가지 않고 쓰기 지연 저장소에 쌓입니다.
4) 트랜잭션 커밋 시점에 flush가 일어나며, 쌓인 SQL이 DB로 반영됩니다.
5) 변경 감지는 최초 상태와 현재 상태를 비교해서 update SQL을 만들어 반영합니다.

## 실무 포인트
- “persist 했는데 쿼리가 바로 안 나가도 이상한 게 아니다”
  - 쓰기 지연 때문에 커밋 때 나가는 경우가 많습니다.
- “update 메서드가 없는데 update가 나간다”
  - 변경 감지로 update SQL이 생성됩니다.
- “같은 트랜잭션 안에서 같은 id는 같은 객체”
  - 동일성 보장 때문에 디버깅할 때 도움이 됩니다.
- 엔티티 변경은 트랜잭션 범위에서 다루는 게 기본입니다.
  - 트랜잭션 밖에서 변경을 기대하면 혼란이 생깁니다.

## 용어 정리
| 용어 | 뜻 |
| --- | --- |
| 1차 캐시 | 영속성 컨텍스트 내부 캐시(Map) |
| 동일성 보장 | 같은 id 재조회 시 같은 객체로 반환되는 성질 |
| 쓰기 지연 저장소 | 변경 SQL을 모아두는 공간 |
| flush | 변경 내용을 DB에 반영하는 동작 |
| 변경 감지 | 최초 상태와 현재 상태 비교로 update SQL을 만드는 메커니즘 |
| LoadedState | 엔티티가 저장될 때 들고 있는 최초 상태(비교 기준) |

## 질문
- find를 두 번 호출했는데 select가 한 번만 나가는 이유를 내 말로 설명할 수 있나요?
- persist 했는데 insert가 커밋 때 나가는 이유는 무엇인가요?
- update 메서드를 호출하지 않았는데 update SQL이 나가는 메커니즘은 무엇인가요?
- flush는 커밋이랑 같은 개념인가요? 어떤 점이 다를까요?
