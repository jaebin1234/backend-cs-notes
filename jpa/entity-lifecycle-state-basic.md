# entity-lifecycle-state-basic.md

## 개요
JPA에서 엔티티는 “상태”가 있습니다.
이 상태에 따라 JPA가 엔티티를 관리할 수도 있고, 아예 관리를 못 할 수도 있습니다.
그래서 같은 객체를 수정해도 어떤 때는 update가 나가고, 어떤 때는 아무 일도 안 생깁니다.

## 정의
- 비영속(Transient)
  - new로 만든 그냥 자바 객체 상태입니다.
  - 영속성 컨텍스트가 전혀 모르는 상태입니다.
- 영속(Managed)
  - 영속성 컨텍스트가 엔티티를 관리하는 상태입니다.
  - 1차 캐시, 동일성 보장, 변경 감지 같은 기능이 적용됩니다.
- 준영속(Detached)
  - 한 번 영속이었는데, 영속성 컨텍스트에서 떨어져 나온 상태입니다.
  - JPA 관리 대상이 아니어서 변경 감지가 안 됩니다.
- 삭제(Removed)
  - 영속 상태인 엔티티를 “삭제 예약”한 상태입니다.
  - 커밋 시점에 delete가 반영됩니다.

## 핵심 개념
- 엔티티 상태를 결정하는 핵심 기준은 “영속성 컨텍스트가 관리 중인가?” 입니다.
- 영속 상태에서만 보통 변경 감지가 됩니다.
- em.contains(entity)로 “지금 관리 중인지” 확인할 수 있습니다.

## 동작 방식

### 상태 전이 플로우(느낌)
비영속
- new Entity()

비영속에서 영속으로
- persist(entity) 또는 find(...)로 조회해서 영속성 컨텍스트에 들어오면 영속

영속에서 준영속으로
- detach(entity) 특정 엔티티만 분리
- clear() 컨텍스트 전체 비우기, 관리 중이던 것 전부 준영속
- close() 컨텍스트 종료, 이후 컨텍스트 자체를 더 못 씀

준영속에서 영속으로(다시 붙이기)
- merge(entity)
  - 주의: merge는 “파라미터로 준영속 객체를 관리 상태로 만드는 것”이라기보다
    “새 영속 객체를 만들어서 값을 복사한 뒤 그 영속 객체를 반환”하는 느낌입니다.

영속에서 삭제로
- remove(entity)

## 전체 흐름

### 1) 비영속(Transient)
- new로 만들었다
- 아직 영속성 컨텍스트에 없음
- 값을 바꿔도 JPA가 변경 감지 못 함
- 그래서 update 같은 게 생기지 않음

### 2) 영속(Managed)
- persist 했다 또는 find로 조회했다
- 영속성 컨텍스트가 관리 시작
- 같은 id 재조회 시 1차 캐시 영향 가능
- 값 변경하면 변경 감지 대상이 됨
- 커밋 시점에 flush 되면서 insert/update/delete가 반영됨

### 3) 준영속(Detached)
- 원래 영속이었는데 분리됨(detach/clear/close)
- 1차 캐시에서도 빠진다고 생각하면 이해가 쉽습니다
- 값을 바꿔도 변경 감지가 안 됨
- 커밋해도 update가 안 나갈 수 있음

### 4) merge(준영속/비영속을 다시 다루는 방식)
- merge를 호출하면 내부적으로 식별자(id) 기준으로 찾아봅니다
  1) 컨텍스트에 있으면 그 관리 객체를 사용
  2) 컨텍스트에 없으면 DB에서 조회해서 관리 객체를 만들거나 가져옴
  3) DB에도 없으면 새로 만들어서 insert 쪽으로 갈 수 있음
- 핵심 포인트
  - merge의 반환값(새로 관리되는 객체)을 이후에 써야 안전합니다
  - 파라미터로 넘긴 원본 객체는 계속 준영속일 수 있습니다

### 5) 삭제(Removed)
- remove(entity)를 호출하면 삭제 상태
- 커밋 시점에 delete 반영

## 실무 포인트
- “영속 상태에서만 변경 감지가 된다” 이 한 줄이 중요합니다.
- detach/clear/close 이후에 엔티티 수정해도 update가 안 나갈 수 있습니다.
- merge는 저장도 되고 수정도 될 수 있습니다.
  - 그래서 실무에서는 merge 사용을 조심하거나, 의도를 명확히 하는 패턴을 씁니다.
- 상태 꼬임이 자주 나는 구간
  - API 계층에서 엔티티를 그대로 밖으로 던지고, 다른 트랜잭션에서 그 엔티티를 다시 쓰려는 경우
  - 해결은 보통 id만 넘기고, 새 트랜잭션에서 다시 조회해서 영속 상태로 다루는 방식입니다.

## 용어 정리
| 용어 | 뜻 |
| --- | --- |
| 비영속 | JPA가 모르는 순수 객체 상태 |
| 영속 | 영속성 컨텍스트가 관리하는 상태 |
| 준영속 | 관리되다가 분리된 상태, 변경 감지 안 됨 |
| 삭제 | 삭제 예약 상태, 커밋 때 delete 반영 |
| detach | 특정 엔티티만 컨텍스트에서 분리 |
| clear | 컨텍스트를 비워서 전부 준영속 |
| close | 컨텍스트 종료, 이후 사용 불가 |
| merge | 새 영속 객체를 만들어 값 병합 후 반환 |

## 질문
- 비영속에서 필드 값을 바꿔도 update가 안 나가는 이유는 무엇인가요?
- detach와 clear의 차이는 무엇인가요?
- merge가 “저장도 되고 수정도 될 수 있다”는 말은 무슨 뜻인가요?
- merge 이후 왜 반환된 객체를 써야 안전할까요?
- close 이후에 find를 하면 왜 에러가 날까요?
