# spring-cloud-basic.md

## 개요

Spring Cloud는 마이크로서비스를 만들고 운영할 때 자주 필요한 기능들을 “묶음”으로 제공하는 Spring 생태계 확장입니다.
서비스가 여러 개로 쪼개지면 필연적으로 생기는 문제(서비스 위치 찾기, 트래픽 분산, 장애 전파 차단, 설정 관리, 요청 진입점 통합)를 표준 방식으로 풀어줍니다.

---

## Spring Cloud가 필요한 이유

모놀리식은 배포 단위가 하나라서 단순하지만, 규모가 커지면 다음 문제가 커집니다.

* 트래픽 증가 대응이 어려움(수평 확장 단위가 큼)
* 장애가 전체로 번질 가능성이 큼
* 팀별로 독립 배포가 어려움
* 설정, 배포, 모니터링 같은 운영 복잡도가 급증

Spring Cloud는 이 “운영 복잡도”를 줄여주는 방향으로 구성 요소를 제공합니다.

---

## 주요 구성 요소 정리

## 1) 서비스 등록과 디스커버리 (Eureka)

서비스가 늘고 줄면 주소(IP, 포트)가 계속 바뀝니다. 이걸 하드코딩하면 바로 깨집니다.
Eureka는 “서비스 주소 전화번호부” 역할을 합니다.

* 서비스 레지스트리
  각 서비스 인스턴스가 자기 위치를 등록해두는 저장소입니다.
* 헬스 체크
  살아있는 인스턴스만 목록에 남기기 위해 주기적으로 상태를 확인합니다.

흐름 요약

* 서비스 실행
* Eureka에 등록
* 다른 서비스나 게이트웨이가 Eureka에서 목록 조회
* 살아있는 인스턴스로 호출

---

## 2) 로드 밸런싱 (Ribbon, Spring Cloud LoadBalancer)

여러 인스턴스가 있을 때, 어느 인스턴스로 요청을 보낼지 결정하는 역할입니다.
Ribbon은 대표적인 “클라이언트 사이드 로드밸런서”로 많이 알려져 있습니다.

* 서버 리스트 제공자
  Eureka에서 인스턴스 목록을 받아옵니다.
* 알고리즘
  라운드 로빈, 가중치 기반 같은 방식으로 분산합니다.
* Failover
  요청 실패 시 다른 인스턴스로 바꿔서 재시도하는 흐름이 붙을 수 있습니다.

실무에서는 “재시도는 신중하게”가 포인트입니다.
무조건 재시도를 켜면 장애 상황에서 트래픽이 더 몰려서 상황을 악화시키기도 합니다.

---

## 3) 서킷 브레이커 (Hystrix, Resilience4j)

마이크로서비스는 호출 체인이 길어질 수 있고, 한 곳이 느려지거나 죽으면 연쇄적으로 장애가 번집니다.
서킷 브레이커는 “망가진 구간을 잠시 끊어서 전체를 살리는 장치”입니다.

* 상태 개념

  * Closed: 정상 호출
  * Open: 실패가 많아서 호출 차단
  * Half-Open: 조금만 호출을 열어서 회복 여부 확인
* Fallback(대체 로직)
  실패 시 대체 응답을 내려서 사용자 경험과 전체 안정성을 유지합니다.
* 모니터링
  서킷 상태를 관측하면서 운영 판단이 가능해집니다.

Resilience4j는 Hystrix 대안으로 많이 쓰이고, 타임아웃/재시도 같은 기능도 함께 묶어서 구성하기 쉽습니다.

---

## 4) API 게이트웨이 (Zuul, Spring Cloud Gateway)

외부 요청의 “단일 진입점” 역할입니다.
클라이언트가 모든 서비스로 직접 붙지 않고, 게이트웨이를 통해 들어옵니다.

* 라우팅
  요청 URL/규칙에 따라 내부 서비스로 전달합니다.
* 필터 체인
  인증, 인가, 로깅, 헤더 처리 같은 공통 기능을 앞단에서 처리합니다.
* 보안
  내부 서비스를 직접 노출하지 않게 막는 효과가 큽니다.
* 효율성
  중앙에서 정책을 적용하니 서비스별 중복 구현이 줄어듭니다.

정리하면, 게이트웨이는 “공통 처리 집중”에 강하지만 병목이 될 수 있어서 다중화가 기본입니다.

---

## 5) 구성 관리 (Spring Cloud Config)

서비스가 많아지면 환경별 설정(dev, prod 등)을 서비스마다 들고 있기가 힘듭니다.
Config는 설정을 중앙에서 관리하고 내려주는 구조입니다.

* Config Server
  설정을 한 곳에서 관리하고 배포합니다.
* Config Client
  서버에서 설정을 받아 사용하는 서비스입니다.
* 설정 갱신
  설정 변경을 서비스 재시작 없이 반영하는 방식도 구성할 수 있습니다.

---

## 6) 그 외 자주 같이 언급되는 것들

* 분산 추적: Sleuth, Zipkin
  요청이 여러 서비스로 흘러갈 때 “한 요청의 전체 이동 경로”를 추적합니다.
* 메시징: Spring Cloud Stream
  이벤트 기반 통신을 Spring 방식으로 연결하기 쉽게 합니다.

---

## Netflix 사례 요약 (왜 MSA로 갔는지)

넷플릭스는 사용자 증가와 장애 경험을 겪으면서 모놀리식 한계가 명확해졌고, 클라우드 전환까지 같이 추진했습니다.

* 확장성: 글로벌 트래픽을 유연하게 수평 확장해야 함
* 신뢰성: 일부 장애가 전체 장애로 번지지 않게 해야 함
* 개발 속도: 팀이 독립적으로 개발/배포할 수 있어야 함

전환 과정 핵심은 “서비스 분리”와 “배포 자동화(CI/CD)”였고, 그 과정에서 Eureka, Ribbon, Hystrix 같은 도구를 직접 만들며 운영 안정성을 끌어올렸다는 흐름입니다.

---

## 실무 포인트 (내 기준으로 기억해둘 것)

* 서비스 디스커버리와 게이트웨이는 “없으면 불편”이 아니라 “운영에서 사실상 필수”에 가깝습니다.
* 로드밸런싱의 재시도, 서킷 브레이커의 타임아웃은 잘못 잡으면 장애 전파를 키웁니다.
* 분산 환경에서 중요한 건 기능 자체보다 “관측(로그, 메트릭, 트레이싱)과 재처리 전략”이 같이 있어야 합니다.

---

## 용어 정리

| 용어                         | 의미                          |
| -------------------------- | --------------------------- |
| Service Discovery          | 서비스 위치를 동적으로 찾는 방식          |
| Eureka                     | 서비스 레지스트리 역할을 하는 디스커버리 서버   |
| Client-side Load Balancing | 클라이언트가 직접 인스턴스를 선택해 분산하는 방식 |
| Circuit Breaker            | 장애 전파를 막기 위해 호출을 차단/완화하는 패턴 |
| Fallback                   | 실패 시 대체 로직/대체 응답            |
| API Gateway                | 외부 요청 단일 진입점, 라우팅과 공통처리 담당  |
| Config Server              | 설정을 중앙에서 관리해 내려주는 서버        |
| Distributed Tracing        | 요청이 여러 서비스로 이동하는 흐름을 추적     |

---

## 공부하면서 떠올릴 질문

* Eureka 기반 환경에서 “서비스 목록 캐시”는 어디에 두는 게 운영적으로 안전할까?
* 게이트웨이에서 JWT 검증을 어디까지 하고, 서비스에서는 무엇을 다시 확인해야 할까?
* 서킷 브레이커 타임아웃 기준은 “평균 응답 시간”이 아니라 무엇을 기준으로 잡아야 할까?
* 재시도는 어떤 경우에만 허용해야 “장애 증폭”을 막을 수 있을까?
