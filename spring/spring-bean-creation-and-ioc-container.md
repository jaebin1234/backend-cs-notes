# spring-bean-creation-and-di-flow-basic.md

## 개요
DI를 하려면 결국 "미리 만들어진 객체"가 필요합니다.
Spring에서는 그 미리 만들어진 객체를 보통 빈(Bean)이라고 부릅니다.
그리고 이 빈들을 만들어서 보관하고, 서로 연결(주입)까지 해주는 곳이 스프링 IoC 컨테이너입니다.

## 정의
- Bean(빈)
  - 스프링이 생성하고 관리하는 객체입니다.
  - 예를 들어 @Service, @Repository, @Controller 같은 애노테이션이 붙은 클래스 인스턴스가 빈이 됩니다.
- Spring IoC 컨테이너
  - 빈을 모아두고, 생성하고, 관계를 연결해주는 컨테이너입니다.
- DI(의존성 주입)
  - 내가 필요한 객체를 new로 직접 만들지 않고, 컨테이너가 만들어둔 빈을 받아서 쓰는 방식입니다.

## 핵심 개념
- "미리 만들어진 객체를 외부에서 주입"한다
  - 여기서 "미리 만들어진 객체"가 바로 빈입니다.
- 강한 결합이 되는 순간
  - Controller나 Service에서 new로 직접 생성하는 순간입니다.
- 느슨한 결합이 되는 순간
  - 생성은 컨테이너가 하고, 나는 필요한 것을 주입받아 쓰는 순간입니다.

## 동작 방식
스프링 서버가 뜰 때(컨테이너 시작 시점) 아래 작업을 합니다.

1) 빈 후보 찾기
- @ComponentScan이 지정된 패키지 아래를 훑습니다.
- @Component 계열(@Controller, @Service, @Repository 포함)이 붙은 클래스를 찾습니다.

2) 빈 등록(목록 만들기)
- "이 클래스는 빈으로 관리할거야" 라는 등록 목록(빈 정의)을 만듭니다.

3) 빈 생성
- 보통 이 시점에 등록된 빈들을 생성합니다.
- 많이 쓰는 기본 스코프가 싱글톤이라, 애플리케이션 전체에서 1개를 만들어 재사용합니다.

4) 의존성 주입(DI)
- Service가 Repository가 필요하면, 컨테이너가 Repository 빈을 찾아서 Service에 넣어줍니다.
- Controller도 마찬가지로 Service 빈을 받아서 씁니다.

5) 초기화(있으면)
- 초기화 콜백이 있으면 이 단계에서 실행됩니다.

## 전체 흐름
[애플리케이션 시작]
- 스프링 부트 실행

[컨테이너 초기화]
- 컴포넌트 스캔으로 빈 후보 찾기
- 빈 등록 목록 만들기
- 빈 생성
- 빈끼리 연결(주입)
- 초기화(있으면)

[요청 처리 시작]
- Client 요청이 들어오면
- Controller가 Service를 호출하고
- Service가 Repository를 호출합니다
- 이때 Controller, Service, Repository는 이미 빈으로 만들어져 있고, 주입도 끝난 상태입니다

## 실무 포인트
- "주입받는 객체"는 빈이어야 합니다.
  - 스프링이 관리하는 객체만 DI 대상으로 사용할 수 있습니다.
- 생성자 주입이 기본 선택이 되는 이유
  - 의존성이 명확해지고, 객체가 생성될 때 필요한 것이 확정됩니다.
  - 불필요한 변경 가능성을 줄이는 데 도움이 됩니다.
- 예외 케이스도 있습니다
  - @Lazy를 쓰면 컨테이너 시작 때 바로 만들지 않고, 실제로 필요할 때 만드는 방식으로 바뀔 수 있습니다.
  - 하지만 기본은 "컨테이너 시작 시 생성"으로 이해하면 충분합니다.

## 용어 정리
| 용어 | 뜻 |
| --- | --- |
| Bean | 스프링이 생성하고 관리하는 객체 |
| IoC | 객체 생성과 연결의 제어권을 컨테이너가 갖는 원칙 |
| DI | 필요한 의존 객체를 외부(컨테이너)에서 주입받는 방식 |
| Component Scan | 애노테이션 기반으로 빈 후보를 찾아 등록하는 과정 |
| Singleton | 기본 빈 스코프, 애플리케이션에서 1개를 만들어 공유 |

## 질문
- "빈 등록"과 "빈 생성"은 같은 말일까요, 다른 말일까요?
- Controller에서 new Service()를 하는 순간 어떤 문제가 바로 생길까요?
- 같은 타입의 빈이 2개면 스프링은 어떤 기준으로 주입할까요?
- @Lazy를 쓰면 전체 흐름에서 어떤 단계가 달라질까요?
