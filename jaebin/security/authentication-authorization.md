
# 인증(Authentication)과 인가(Authorization)

## 핵심 개념

* 인증(Authentication)
  사용자가 누구인지 확인하는 과정입니다.
  예) 아이디/비밀번호 입력, 휴대폰 본인인증, 공인인증서·인증서 로그인 등

* 인가(Authorization)
  인증된 사용자가 어떤 자원과 기능에 접근할 수 있는지 권한을 결정하는 과정입니다.
  예) 일반 사용자는 자기 정보만 조회 가능, 관리자는 전체 회원 조회 가능 등

* 관계
  일반적으로 “인증 → 인가” 순서로 진행되며, 인증이 이루어지지 않으면 인가(권한 검사)도 의미가 없습니다.

---

## 인증 방식 전체 그림

대표적인 인증 방식은 흐름 관점에서 다음과 같이 나눌 수 있습니다.

1. 가장 기본: 아이디/비밀번호 로그인
2. 로그인 상태 유지: 세션(Session) 기반 인증
3. 서버 상태를 최소화: 토큰(Token) 기반 인증(JWT 등)
4. 제3자에게 권한 위임: OAuth 2.0 (소셜 로그인 등)
5. 추가 보안 계층: MFA(다중 요소 인증), SSO(싱글 사인온) 등

아래에서 각 방식을 간단히 정리합니다.

---

## 1. 아이디/비밀번호 기반 로그인

사용자가 해당 서비스에 직접 계정을 만들고, 아이디/비밀번호를 이용해 로그인하는 가장 기본적인 방식입니다.

* 특징

  * 구현이 비교적 쉽고 가장 많이 사용되는 패턴입니다.
  * 비밀번호는 반드시 단방향 해시(bcrypt, scrypt, Argon2 등)를 적용해 저장해야 합니다.
  * 비밀번호 정책(길이, 특수문자 포함, 재사용 금지 등)과 계정 잠금 정책(여러 번 실패 시 잠금 등)이 중요합니다.

* 한계

  * 비밀번호 유출 위험이 존재합니다(피싱, 키로깅, 여러 서비스에서의 비밀번호 재사용 등).
  * 추가 인증 수단(MFA)을 적용하지 않으면 보안 수준이 상대적으로 낮습니다.

---

## 2. 세션 기반 인증 (Session-based Authentication)

서버가 “로그인 상태”를 서버 메모리 또는 별도 저장소에 유지하고, 클라이언트는 세션 ID만 쿠키로 들고 다니는 방식입니다.

* 기본 흐름

  1. 사용자가 아이디/비밀번호로 로그인 요청을 보냅니다.
  2. 서버가 인증에 성공하면 세션 저장소(메모리, Redis 등)에 세션 객체를 만들고 세션 ID를 생성합니다.
  3. 세션 ID를 쿠키에 담아 `Set-Cookie` 헤더로 클라이언트에 내려 줍니다.
  4. 이후 요청마다 브라우저가 쿠키를 자동으로 전송하고, 서버는 세션 ID로 세션을 조회해 사용자 정보를 복원합니다.

* 장점

  * 서버에서 세션을 삭제하면 즉시 로그아웃 처리가 가능합니다.
  * 세션에 필요한 정보를 자유롭게 저장할 수 있어 유연합니다.
  * 쿠키만 안전하게 관리하면 구조와 동작을 이해하기 쉬운 편입니다.

* 단점

  * 서버가 세션 상태를 가지고 있으므로 서버 확장 시 세션 공유(세션 클러스터링, Redis 세션 저장소 등) 설계가 필요합니다.
  * 쿠키 기반이므로 CSRF(Cross-Site Request Forgery)에 취약할 수 있어 방어 전략(CSRF 토큰, SameSite 설정 등)이 중요합니다.

---

## 3. 토큰 기반 인증 (Token-based Authentication, JWT 등)

서버가 “로그인 상태”를 서버 메모리에 유지하지 않고, 서명된 토큰을 클라이언트에 발급한 뒤, 그 토큰을 매 요청마다 전송해 검증하는 방식입니다.

* 기본 개념

  * 토큰(Token): 서명된 문자열(대표적으로 JWT)로, 사용자 정보, 권한 정보, 만료 시간 등의 클레임을 포함합니다.
  * 서버는 토큰의 서명을 검증하고, 유효하다면 해당 요청을 처리합니다.
  * 서버 비밀키로 서명했기 때문에, 별도 DB 조회 없이도 토큰 검증만으로 일정 수준 신뢰할 수 있습니다.

* 기본 흐름

  1. 로그인에 성공하면 서버가 액세스 토큰(Access Token)을 발급합니다.
  2. 클라이언트는 토큰을 저장(로컬 스토리지, 메모리, 쿠키 등)하고, 이후 요청의 `Authorization: Bearer <token>` 헤더에 실어 보냅니다.
  3. 서버는 토큰 서명을 검증하고, 만료 여부와 클레임을 확인해 사용자와 권한을 판단합니다.

* 장점

  * 서버가 세션 상태를 거의 가지지 않기 때문에 수평 확장에 유리합니다.
  * 여러 서비스가 동일한 토큰을 검증해 공유할 수 있으므로 마이크로서비스 아키텍처에 적합합니다.

* 단점

  * 토큰이 탈취되면 만료 시간까지 계속 악용될 수 있습니다. 짧은 만료 시간 + 리프레시 토큰 전략이 필요합니다.
  * 이미 발급된 토큰을 임의로 “강제 만료”시키기 어렵습니다. 블랙리스트, 토큰 버전 필드, 로그아웃 처리 전략 등이 필요합니다.
  * 토큰 저장 위치(쿠키, 로컬 스토리지, 메모리 등)에 따라 XSS/CSRF 등 공격 벡터가 달라집니다.

---

## 4. OAuth 2.0 (소셜 로그인, 권한 위임)

OAuth 2.0은 기본적으로 “인가(Authorization)”를 위한 프레임워크입니다.
사용자가 직접 비밀번호를 서비스에 제공하지 않고, 구글·카카오와 같은 외부 서비스에 “내 정보에 접근할 수 있는 권한”만 위임하는 방식입니다.

* 등장 배경

  * “구글 계정으로 로그인”, “카카오로 회원가입”과 같은 소셜 로그인 기능을 제공하기 위해 사용됩니다.
  * 비밀번호를 공유하지 않고, 특정 범위(scope)의 권한만 제한적으로 허용하고자 할 때 필요합니다.

* 주요 역할(Role)

  * Resource Owner: 실제 사용자(자원 소유자).
  * Client: 사용자를 대신해 자원에 접근하는 애플리케이션(예: 쇼핑몰 서버).
  * Authorization Server: 로그인과 동의 화면 제공, 토큰 발급을 담당하는 서버(예: 구글 계정 서버).
  * Resource Server: 사용자 데이터를 가진 API 서버(예: Google People API 등).

* 대표 플로우 – Authorization Code Grant (서버 사이드 웹에서 많이 사용)

  1. 사용자가 “구글로 로그인” 버튼을 클릭하면, 브라우저가 구글 로그인 페이지로 리다이렉트됩니다.
  2. 사용자가 구글 계정으로 로그인하고 권한(프로필 정보 조회 등)에 동의합니다.
  3. Authorization Server가 등록된 콜백 URL로 Authorization Code를 전달합니다.
  4. 애플리케이션 서버는 Authorization Code를 이용해 백엔드에서 액세스 토큰을 요청합니다.
  5. 발급받은 액세스 토큰으로 구글 API를 호출해 프로필 정보를 조회하고, 이를 자체 회원 시스템과 매핑합니다.

* 인증과의 관계

  * OAuth 2.0은 원래 “인가(권한 위임)”를 표준화한 프레임워크이며, “사용자가 누구인지”를 규정하는 표준은 아닙니다.
  * 사용자의 식별 정보까지 포함하여 “로그인 프로토콜”로 사용하려면 일반적으로 OAuth 2.0 위에 OpenID Connect(OIDC)를 추가해 사용합니다.

---

## 5. 세션 vs 토큰 vs OAuth 2.0 비교

* 세션 기반 인증

  * 전통적인 웹 서비스(서버 사이드 렌더링, 단일 도메인 환경)에 적합합니다.
  * 서버가 상태(세션)를 저장하므로, 확장 시 세션 저장소 설계(공유 저장소 등)가 필요합니다.

* 토큰 기반 인증(JWT 등)

  * API 서버, 모바일 앱, SPA, 마이크로서비스 환경에 적합합니다.
  * 서버는 stateless에 가까워 확장에 유리하지만, 토큰 폐기 및 보안 전략을 별도로 설계해야 합니다.

* OAuth 2.0

  * 외부 서비스 계정(구글, 카카오 등)을 활용하거나, 제3자 애플리케이션이 내 API에 접근하도록 할 때 사용합니다.
  * 자체 인증 시스템 위에 “소셜 로그인” 또는 “외부 계정 연동”으로 덧붙이는 형태로 많이 사용됩니다.

---

## 실무에서 고려할 포인트

* 저장 위치

  * 세션 ID는 일반적으로 HttpOnly 쿠키에 저장해 XSS에 의한 노출을 줄이는 것이 좋습니다.
  * 토큰은 로컬 스토리지, 메모리, 쿠키 등 어디에 저장하느냐에 따라 보안 트레이드오프가 달라집니다.

* 만료와 로그아웃

  * 세션 기반은 서버에서 세션을 삭제하면 즉시 로그아웃 처리가 가능합니다.
  * 토큰 기반은 만료 시간, 리프레시 토큰, 블랙리스트, 토큰 버전 필드 등을 조합하여 만료/로그아웃 전략을 설계해야 합니다.

* CSRF vs XSS

  * 세션/쿠키 기반에서는 CSRF 방어(CSRF 토큰, SameSite 쿠키 설정 등)가 중요합니다.
  * 토큰을 JavaScript에서 접근 가능한 저장소에 둘 경우, XSS로 탈취될 위험이 커집니다.

* MFA / SSO

  * 중요도가 높은 서비스라면 ID/PW만 사용하는 것보다 SMS, OTP, 인증 앱 등 MFA를 도입하는 것이 일반적입니다.
  * 여러 시스템 간에 한 번의 로그인으로 모두 이용 가능하게 하려면 SSO(IdP, SAML, OIDC 등)를 사용합니다.

---

## 용어 정리

| 키워드                              | 설명                                                     |
| -------------------------------- | ------------------------------------------------------ |
| 인증(Authentication)               | 사용자가 누구인지 확인하는 과정                                      |
| 인가(Authorization)                | 인증된 사용자가 어떤 자원과 기능을 사용할 수 있는지 권한을 확인하는 과정              |
| 세션(Session)                      | 서버 측에 저장되는 로그인 상태 정보. 사용자별 고유 세션 ID가 매핑됨               |
| 세션 ID(Session ID)                | 세션을 식별하기 위한 토큰 문자열. 보통 쿠키로 클라이언트에 전달됨                  |
| 세션 기반 인증                         | 서버가 세션 상태를 저장하고, 클라이언트는 세션 ID만 들고 다니는 인증 방식            |
| 토큰(Token)                        | 인증/인가 정보를 담고 서명된 문자열. 서버는 토큰 검증으로 사용자를 식별              |
| JWT(Json Web Token)              | JSON 기반 토큰 포맷. 헤더, 페이로드, 서명으로 구성되며 주로 Bearer 토큰으로 사용   |
| 액세스 토큰(Access Token)             | 보호 자원(API)에 접근할 때 사용하는 토큰. 비교적 짧은 만료 시간을 가짐            |
| 리프레시 토큰(Refresh Token)           | 액세스 토큰 만료 시 새 액세스 토큰을 받기 위한 토큰. 더 긴 만료 시간과 높은 보호 수준 필요 |
| OAuth 2.0                        | 클라이언트가 자원 소유자를 대신해 자원 서버에 접근할 수 있도록 권한을 위임하는 인가 프레임워크  |
| OpenID Connect(OIDC)             | OAuth 2.0 위에 사용자의 인증 정보를 표준화해 “로그인”을 구현할 수 있게 하는 프로토콜  |
| Resource Owner                   | 실제 자원(데이터)의 소유자, 보통 최종 사용자                             |
| Client                           | 사용자를 대신해 자원에 접근하는 애플리케이션(예: 서비스 백엔드)                   |
| Authorization Server             | 로그인/동의 처리 후 토큰을 발급하는 서버                                |
| Resource Server                  | 사용자 데이터(API)를 실제로 제공하는 서버                              |
| MFA(Multi-Factor Authentication) | 두 가지 이상 인증 수단을 사용하는 인증 방식. 예: 비밀번호 + SMS 코드            |
| SSO(Single Sign-On)              | 한 번 로그인으로 여러 시스템에 동시에 로그인된 효과를 제공하는 방식                 |
| 세션 하이재킹(Session Hijacking)       | 세션 ID를 탈취해 다른 사용자인 것처럼 위장하는 공격                         |
| 토큰 탈취(Token Theft)               | 토큰을 훔쳐 유효 기간 동안 권한을 악용하는 공격                            |
