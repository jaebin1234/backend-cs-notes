# 2026-02-19 TIL

---

## Today I Learned

### spring ai

#### 1. 소개: Spring AI
- Spring에서 LLM을 라이브러리처럼 붙여서, 대화, 프롬프트, 구조화 출력, 메모리, 어드바이저 같은 공통 문제를 표준 방식으로 처리하게 해주는 프레임워크 느낌.
- 결국 목표는 모델 호출 자체보다, 실무에서 반복되는 패턴(옵션, 컨텍스트, 검증, 포맷)을 코드로 안정적으로 만드는 쪽.

#### 2. 텍스트 대화: Chat Model API
- Chat Model API는 메시지 묶음을 모델에 보내고, 응답을 ChatResponse 같은 표준 형태로 받는 구조.
- 보통 System, User, Assistant 메시지를 쌓아서 한 번에 요청하고, 옵션으로 모델 동작을 튜닝한다.

ChatModel / StreamingChatModel 차이
- ChatModel은 응답을 한 번에 받는 방식이라 구현이 단순하고, 일반 API 서버 응답에 붙이기 쉽다.
- StreamingChatModel은 토큰이 오자마자 흘려보내는 방식이라 체감 속도가 좋아지고, UI 스트리밍에 유리하다.

Prompt 클래스
- Prompt는 메시지들 + 옵션을 합쳐서 모델에 전달하는 요청 단위라고 보면 된다.
- 프롬프트 엔지니어링 결과물을 코드 객체로 관리하는 느낌.

Message 인터페이스
- Message는 역할(System/User/Assistant)과 콘텐츠를 가진 대화 단위.
- 결국 대화 기록은 Message 리스트로 관리된다고 생각하면 편하다.

ChatOptions 인터페이스, ChatResponse 클래스, Generation 클래스
- ChatOptions는 temperature 같은 튜닝 값, 모델 선택, 기타 호출 옵션들을 담는 그릇.
- ChatResponse는 전체 응답 컨테이너, Generation은 그 안의 실제 생성 결과 한 덩어리라고 이해했다.

ChatModel vs ChatClient 비교
- ChatModel은 모델 호출 인터페이스에 가까워서, 내가 직접 Prompt/Message를 구성하는 느낌이 강하다.
- ChatClient는 편하게 쓰는 고수준 클라이언트 느낌이라, 체인처럼 조립하고 Advisor 같은 기능이 붙기 좋다.

#### 3. 프롬프트 엔지니어링
상황, 내용, 형식 (중요)
- 상황(Context)은 너는 누구고, 지금 뭐 하는 중이고, 어떤 제약이 있는지 같은 바탕을 잡아주는 영역.
- 내용(Task)은 그래서 뭘 해줘를 딱 한 문장으로 고정하는 핵심.
- 형식(Format)은 출력 모양을 고정해서 결과가 흔들릴 여지를 줄이는 장치.

PromptTemplate
- PromptTemplate은 텍스트에 변수를 박아두고, 런타임에 값만 채워서 프롬프트를 일관되게 찍어내는 방식.
- 결국 프롬프트도 코드처럼 재사용/관리하려는 도구.

SystemMessage, UserMessage, AssistantMessage
- SystemMessage는 룰과 역할을 고정하는 느낌이라, 출력 품질과 안전장치를 만들 때 중요하다.
- UserMessage는 실제 요청, AssistantMessage는 이전 답변(대화 맥락)으로 쌓인다.

프롬프트 엔지니어링 기법들
- 제로샷: 예시 없이 바로 시키는 방식, 간단하지만 결과가 튈 수 있다.
- 퓨샷: 예시를 1개 이상 넣어서 원하는 패턴을 학습시키는 방식.
- 역할 부여: 너는 리뷰어/면접관/시니어 개발자처럼 관점을 박아두는 방식.
- 스텝백: 바로 풀기 전에 한 발 물러서서 조건/목표를 정리하게 만드는 방식.
- 생각의 사슬: 중간 사고 과정을 유도해서 복잡한 문제에서 안정성을 올리는 방식(근데 너무 믿으면 사고 날 수 있음).
- 자기 일관성: 여러 번 뽑아보고 가장 일관된 답을 고르는 느낌.

#### 4. 구조화된 출력
StructuredOutputConverter
- 모델 출력이 텍스트로만 오면 불안하니까, 정해진 타입(T)으로 파싱해서 쓰는 역할.
- 실무에서는 JSON 같은 고정 포맷으로 받게 해서 후처리를 단단하게 만든다.

FormatProvider
- 모델에게 이 포맷으로 내놔라고 알려주는 포맷 안내자 역할.
- 프롬프트에 포맷 지시를 자동으로 섞어주는 느낌.

Converter<String, T>
- 최종적으로는 문자열을 T로 바꾸는 변환기가 핵심.
- 파싱 실패, 누락 필드 같은 케이스를 어떻게 처리할지가 실무 포인트.

구현체(저수준, 고수준)와 기본 컨버터들
- 저수준은 내가 포맷 정의, 파싱, 검증을 더 직접 컨트롤하는 느낌.
- 고수준은 ListOutputConverter, BeanOutputConverter, MapOutputConverter 같은 걸로 빠르게 타입을 맞춘다.

#### 5. Advisor
전처리와 후처리
- 전처리는 프롬프트를 강화하고 컨텍스트를 더 넣어서 모델이 실수할 확률을 줄이는 작업.
- 후처리는 응답이 이상하면 검증해서 걸러내고, 우리 쪽에서 쓰기 좋게 변환하는 단계.

Advisor Chain 구조
- 여러 Advisor를 체인으로 엮어서, 요청 전과 응답 후에 단계적으로 처리한다.
- 필터 체인 같은 느낌이라, 공통 로직을 깔끔하게 분리하기 좋다.

활용 가능한 공통 기능과 Spring AI Advisor API
- 공통 기능은 보통 컨텍스트 주입, 정책 적용, 포맷 고정, 검증, 로깅 같은 데 쓴다.
- Advisor API로 이 흐름을 표준 방식으로 붙일 수 있어서, 팀 단위로 규칙을 유지하기 편해진다.

#### 6. 대화기억
ChatMemory
- 대화 기억은 이전 메시지들을 저장해두고, 다음 요청에 필요한 만큼 꺼내 쓰는 개념.
- 기억이 없으면 모델은 매번 처음 보는 사람처럼 답해서 서비스 경험이 깨진다.

대화 기억을 위한 Advisor
- 메모리도 Advisor로 붙여서, 요청 전에 과거 메시지를 컨텍스트로 합치는 방식이 자연스럽다.
- 정리하면 대화 기억은 프롬프트 전처리 쪽에 가깝다.

In-Memory, VectorStore, RDBMS, Cassandra 대화 기억
- In-Memory는 간단하지만 서버 재시작이나 스케일 아웃에서 끊길 수 있다.
- VectorStore는 의미 기반 검색이 강점이라, 긴 대화나 문서 기반 QnA에 유리하다.
- RDBMS는 운영과 정합성이 편해서 서비스 로그형 대화 저장에 무난하다.
- Cassandra는 대규모 쓰기와 분산이 필요한 쪽에서 선택하는 느낌.

---

## 오늘의 궁금증

- 실무에서 상황/내용/형식을 어느 정도까지 강하게 고정해야, 유연함이 죽지 않고 품질도 유지될까?
- ChatClient를 쓰는 기준은 뭘로 잡는 게 좋을까? 단순 호출이면 ChatModel, 체인과 공통정책이면 ChatClient 같은 느낌일까?
- StructuredOutputConverter에서 파싱 실패하면, 재시도 프롬프트를 자동으로 돌리는 게 일반적인 패턴일까?
- Advisor Chain이 많아질 때, 디버깅은 어떤 방식(로그 구조, 트레이싱 키)으로 잡는 게 베스트일까?
- 대화기억을 VectorStore로 갈 때, 얼마나 저장하고 얼마나 검색할지 기준을 어떻게 잡아야 비용이 터지지 않을까?

---

## 실습 내용

- ChatModel / StreamingChatModel
- Prompt
- SystemMessage, UserMessage, AssistantMessage
- ChatModel vs ChatClient
- PromptTemplate
- Converter
- Advisor
- 대화기억은 개념만