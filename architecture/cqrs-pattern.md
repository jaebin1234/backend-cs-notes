# CQRS (Command Query Responsibility Segregation)

---

## 1. CQRS란?

CQRS는 “명령(Command)”과 “조회(Query)”의 책임을 분리하는 아키텍처 패턴입니다.  
즉, 상태를 변경하는 모델과 상태를 조회하는 모델을 의도적으로 나눠서 설계하는 방식입니다.

- Command: 주문 생성, 결제, 주문 취소, 회원 정보 수정 등 “상태 변경”
- Query: 주문 목록 조회, 결제 내역 조회, 사용자 정보 조회 등 “데이터 조회”

일반적인 CRUD 모델에서는 한 개의 엔티티/서비스가 “쓰기 + 읽기”를 모두 담당하지만,  
CQRS에서는 “쓰기 영역 모델”과 “읽기 영역 모델”을 분리합니다.

---

## 2. CQRS 패턴 개념

### 2.1 기본 아이디어

1) 상태 변경용 모델 (Command Model)

- 책임: 비즈니스 규칙 검증, 상태 전이(도메인 로직), 트랜잭션 처리
- 특징:
  - “결과만 알면 되는” 명령이 많으므로, 보통 최소한의 데이터만 응답하거나 `void`로 끝나는 경우가 많습니다.
  - 불변식(invariant), 도메인 규칙을 강하게 지키는 쪽입니다.
  - RDB + 트랜잭션, 도메인 모델, 애그리게잇 같은 개념을 잘 녹이는 쪽입니다.

2) 조회용 모델 (Query Model)

- 책임: 화면/클라이언트에서 원하는 형태로 빠르게 조회
- 특징:
  - 읽기 전용 모델, 읽기 전용 저장소를 따로 둘 수 있습니다.
  - 화면에 최적화된 DTO, View Table, 캐시, NoSQL 등을 자유롭게 사용합니다.
  - 복잡한 조인이나 집계를 가져오기 쉽게 “비정규화된 뷰 테이블”을 써도 됩니다.

3) 공통 원칙

- Command 모델과 Query 모델의 스키마/코드를 “강하게” 분리한다.
- Command 처리 결과를 Query 저장소로 “동기화”해 줘야 한다.
  - 동기 / 비동기 이벤트, 메시지 큐, CDC 등 여러 방식 사용 가능
  - 대부분 “최종적 일관성(eventual consistency)”를 전제로 합니다.

---

## 3. CQRS 핵심 내용 정리

### 3.1 왜 쓰는가?

- 읽기와 쓰기의 요구사항이 다르기 때문입니다.
  - 쓰기: 강한 일관성, 도메인 규칙, 트랜잭션이 중요
  - 읽기: 응답 속도, 화면 최적화된 데이터 구조, 캐시/검색이 중요
- 한 모델에서 둘 다 해결하려다 보면, 엔티티/서비스 코드가 점점 비대해지고 유지보수가 어려워집니다.
- CQRS는 “역할”을 분리해서, 각 모델이 자신의 역할에만 집중하게 만듭니다.

### 3.2 언제 쓰는 게 좋을까?

- 읽기 트래픽이 쓰기보다 훨씬 많은 시스템
  - 예: 주문은 상대적으로 적지만, 주문 조회/리스트/검색은 매우 많은 쇼핑몰
- 읽기 모델이 화면/도메인별로 계속 바뀌는 시스템
  - 예: 관리자/사용자/파트너 등마다 다른 조회뷰가 필요한 경우
- 도메인 로직이 복잡하고, 엔티티/서비스 코드가 지나치게 비대해지는 경우
- 서로 다른 저장소 조합이 필요한 경우
  - 예: 쓰기 = RDB, 읽기 = Redis/Elasticsearch/NoSQL

### 3.3 장점

- 유지보수성 향상
  - Command 쪽은 도메인 규칙, 트랜잭션에만 집중
  - Query 쪽은 조회 최적화, 캐시, 뷰 모델에만 집중
- 성능/확장성 튜닝이 쉬움
  - 쓰기/읽기를 서로 다른 DB, 다른 인프라로 분리해서 스케일링 가능
  - 읽기 전용 저장소를 별도로 두고, 캐시/검색 엔진을 마음껏 활용 가능
- 기술 스택을 용도별로 다르게 선택 가능
  - Command: JPA/도메인 모델 중심
  - Query: MyBatis/QueryDSL/순수 SQL, NoSQL, Redis, Elasticsearch 등

### 3.4 단점 및 주의사항

- 구현 복잡도 증가
  - 모델, 서비스, 저장소, 이벤트/싱크 로직이 2배로 늘어납니다.
- 데이터 동기화 이슈
  - Command 결과가 Query 저장소에 반영되기 전까지 “약간의 시간차”가 생길 수 있습니다.
  - “왜 바로 안 보이냐?” 같은 UX 이슈를 고려해야 합니다.
- 작은/단순한 서비스에는 과한 설계일 수 있음
  - 단일 모델로도 충분히 유지보수 가능한데 CQRS를 넣으면 오히려 개발 비용만 증가할 수 있습니다.

즉, “단일 모델의 복잡도 vs CQRS 도입의 복잡도”를 비교해서,  
도메인 복잡도·트래픽·확장성 요구가 충분히 클 때 선택하는 것이 좋습니다.

---

## 4. 예시 1: 전자상거래 주문 시스템 (서로 다른 저장소)

시나리오: 전자상거래(쇼핑몰)에서 주문 생성/결제/취소와 주문 내역 조회를 운영한다고 가정하겠습니다.

1) Command 모델 (쓰기)

- 저장소: RDB (PostgreSQL 등)
- 모델:
  - `Order` 애그리게잇 (Order, OrderLine, PaymentInfo 등)
- 역할:
  - 주문 생성, 결제 요청, 주문 상태 변경(결제 완료, 배송 중, 취소 등)
  - 도메인 규칙:
    - 재고 체크
    - 결제 상태와 주문 상태 일치
    - 포인트/쿠폰 사용 규칙 검증
- 처리가 끝나면 “주문 생성됨”, “주문 상태 변경됨” 같은 이벤트 발행

2) Query 모델 (읽기)

- 저장소: NoSQL(예: MongoDB), Redis, Elasticsearch, 또는 RDB의 View/Table
- 모델:
  - `OrderSummary`
  - `OrderDetailView`
- 역할:
  - 마이페이지 주문 목록, 주문 상세 조회, 검색 필터(기간, 상태, 상품명 등)에 최적화된 구조로 저장
  - 비정규화된 테이블/문서 구조: 주문 + 배송지 + 결제요약 + 대표 상품명 등을 한 번에 조회
- Command 쪽에서 발행한 이벤트를 소비해서, Query 저장소의 `OrderSummary`/`OrderDetailView`를 업데이트

3) 특징

- Command 쪽은 도메인/트랜잭션에 집중.
- Query 쪽은 조회 빠르게, 화면 요구에 최적화.
- 서로 다른 저장소/인덱스를 활용할 수 있고, 읽기 부분을 별도로 수평 확장하기 쉽습니다.

---

## 5. 예시 2: 포인트/정산 + 통계 대시보드 (같은 DB, 다른 접근 기술)

시나리오: 한 서비스에서 사용자 포인트 충전/사용/정산과,  
관리자용 통계 대시보드를 제공한다고 가정하겠습니다.

1) Command 모델 (쓰기, 도메인 중심)

- 저장소: 동일한 RDB (예: PostgreSQL)
- 접근 기술: JPA + 도메인 모델
- 모델:
  - `PointAccount` (총 포인트, 상태)
  - `PointHistory` (충전/사용/취소 기록)
- 역할:
  - 포인트 충전/사용/취소 로직
  - 낙관적 락 / 트랜잭션으로 정합성 유지
  - 정산 배치 시 포인트 합산, 월별 정산 등 도메인 규칙 처리

2) Query 모델 (조회, 리포팅/통계 최적화)

- 저장소: 같은 DB 안의 통계/뷰 테이블, 혹은 별도 통계 스키마
- 접근 기술: MyBatis 또는 순수 SQL
- 모델:
  - `PointUsageStatsView` (일/월별 사용량, 충전량, 소멸량)
  - `TopUsersView` (포인트 사용 상위 유저)
- 역할:
  - 관리자 대시보드용 통계 통합 조회
  - 복잡한 집계/조인/윈도우 함수 등을 SQL로 직접 최적화
- Command(포인트 도메인) 쪽 배치나 트리거/이벤트를 통해 통계 뷰를 주기적으로 갱신

3) 특징

- 데이터베이스는 같은 곳을 써도, “도메인 로직용 JPA 모델”과 “조회 최적화된 SQL/MyBatis 쿼리”를 분리할 수 있습니다.
- 도메인 모델이 통계/뷰 요구사항 때문에 더럽혀지지 않고,  
  통계 쪽도 도메인 규칙/트랜잭션 로직과 섞이지 않아 유지보수가 쉽습니다.

---

## 6. 키워드 / 용어 정리

| 키워드                        | 설명 |
|-----------------------------|------|
| CQRS                        | Command와 Query 책임을 분리하는 아키텍처 패턴입니다. |
| Command                     | 데이터를 변경하는 작업(생성, 수정, 삭제). 도메인 규칙, 트랜잭션이 중요합니다. |
| Query                       | 데이터를 조회하는 작업. 화면/응답 형태, 속도에 최적화하는 것이 중요합니다. |
| Command Model               | 상태 변경을 담당하는 도메인 모델 계층입니다. 주로 RDB + 도메인 로직으로 구성됩니다. |
| Query Model                 | 조회 전용으로 설계된 모델 계층입니다. View Table, 캐시, NoSQL 등을 자유롭게 사용할 수 있습니다. |
| Eventual Consistency        | Command와 Query 저장소 사이에 잠시 불일치가 있을 수 있지만, 결국 일관된 상태로 수렴하는 일관성 모델입니다. |
| Read/Write 분리             | 쓰기와 읽기 경로를 논리적으로/물리적으로 분리하여 확장성과 성능을 높이는 설계입니다. |
| 도메인 모델 (Domain Model)  | 비즈니스 규칙과 상태 전이를 코드로 표현한 모델입니다. 주로 Command 영역에서 중요합니다. |
| View Model / View Table     | 화면/요청에 맞춰 비정규화된 조회 전용 데이터 모델입니다. Query 영역에서 사용됩니다. |
| 동기화(Sync) / 이벤트 전파   | Command 결과를 Query 저장소로 반영하기 위한 메커니즘입니다. 이벤트, 메시지 큐, CDC 등을 사용할 수 있습니다. |

---
