# load-balancing.md

## 개요

로드 밸런싱은 트래픽을 여러 서버(인스턴스)로 나눠서, 한 곳에만 몰리지 않게 만드는 방식입니다.
결과적으로 성능과 가용성이 올라가고, 특정 인스턴스 장애에도 전체가 덜 흔들리게 됩니다.

로드 밸런싱은 크게 두 가지로 나눠서 생각할 수 있습니다.

* 클라이언트 사이드 로드 밸런싱: 호출하는 쪽이 인스턴스를 골라서 요청
* 서버 사이드 로드 밸런싱: 앞단(L4/L7 같은)에서 인스턴스를 골라서 전달

이번 챕터는 클라이언트 사이드 방식 중심입니다.

---

## 클라이언트 사이드 로드 밸런싱

클라이언트 사이드 로드 밸런싱은 “클라이언트가 서버 목록을 알고 직접 선택”하는 방식입니다.
여기서 클라이언트는 브라우저가 아니라, 다른 마이크로서비스(예: Order 서비스)가 될 수 있습니다.

핵심 흐름은 단순합니다.

* 서비스 디스커버리(Eureka)에서 대상 서비스의 인스턴스 목록을 가져온다
* 그중 하나를 알고리즘으로 선택해서 호출한다

---

## FeignClient 개요

FeignClient는 Spring Cloud에서 제공하는 선언적 HTTP 클라이언트입니다.
인터페이스와 어노테이션만으로 “다른 서비스 API 호출”을 코드로 깔끔하게 정의할 수 있습니다.

FeignClient가 좋은 이유는 이런 느낌입니다.

* 호출 코드가 인터페이스 형태로 정리되어서 보기 편함
* Eureka와 연결되면 서비스 이름 기반 호출이 가능함
* 로드 밸런싱까지 자연스럽게 붙어서 동작 흐름이 깔끔함

강의에서는 FeignClient가 Eureka와 연동되어 서비스 인스턴스를 조회하고, Ribbon이 로드 밸런싱을 해주는 구조로 설명했습니다.

---

## Ribbon 개요

Ribbon은 넷플릭스가 만든 클라이언트 사이드 로드 밸런서입니다.
서비스 인스턴스들 사이에 요청을 분배하는 역할을 합니다.

Ribbon이 하는 일은 딱 이거예요.

* Eureka에서 받은 서비스 인스턴스 리스트를 가지고
* 알고리즘(라운드 로빈 등)으로 하나를 골라서
* 그 인스턴스로 요청을 보낸다
* 실패하면 다른 인스턴스로 바꿔서 처리할 수 있다(Failover)

---

## FeignClient 설정 흐름

기본적으로 필요한 건 아래 두 가지 의존성이었습니다.

* eureka client
* openfeign

그리고 애플리케이션에 @EnableFeignClients 를 켜고,
FeignClient 인터페이스를 만들어서 서비스 이름으로 연결합니다.

포인트는 이거예요.

* @FeignClient(name="my-service")의 name은 Eureka에 등록된 서비스 이름을 바라본다
* 실제 주소는 몰라도 된다
* 내부에서 인스턴스 선택과 호출이 이어진다

---

## 로드 밸런싱 알고리즘

강의에서 나온 알고리즘을 “감 잡기용”으로 정리하면 아래 느낌입니다.

* 라운드 로빈
  순서대로 돌아가면서 분배, 가장 직관적
* 가중치 기반
  서버 성능이 다를 때 비율을 다르게 줘서 분배
* 최소 연결
  지금 연결이 가장 적은 서버로 보냄
* 응답 시간 기반
  빠른 서버 위주로 보내는 방식

실습에서는 라운드 로빈을 눈으로 확인하는 형태였습니다.

---

## FeignClient + Eureka + Ribbon 동작 원리

강의 흐름을 그대로 묶으면 이렇게 정리할 수 있습니다.

1. @FeignClient(name="product-service")로 “서비스 이름”을 지정
2. Order 서비스가 Eureka에서 product-service 인스턴스 목록을 조회
3. Ribbon이 인스턴스 목록 중 하나를 선택(기본 라운드 로빈 같은 방식)
4. 선택된 인스턴스로 요청
5. 요청이 계속 들어오면 다른 인스턴스로 순차적으로 분배되는 걸 확인 가능

---

## 시나리오로 이해하기

강의에서 말한 상황을 그대로 옮기면 이렇습니다.

* Order 서비스 인스턴스: 1개
* Product 서비스 인스턴스: 3개(포트만 다름)

Order가 Product를 호출할 때마다
Product 응답 문자열에 “내가 실행 중인 포트”를 붙여서 반환하게 만들면,
요청을 여러 번 날릴 때마다 포트가 바뀌면서 라운드 로빈이 보입니다.

---

## 실습 요약

## 1) Eureka Server

서비스 디스커버리 챕터에서 만들었던 Eureka Server를 그대로 사용합니다.
대시보드에서 인스턴스 등록 상태를 확인합니다.

## 2) Product 인스턴스 3개 띄우기

* product-service 이름으로 Eureka에 등록
* 같은 코드를 포트만 바꿔서 3개 실행(19092, 19093, 19094)
* 응답에 server.port를 포함해서 “어느 인스턴스가 응답했는지” 보이게 함

인텔리제이에서는 실행 구성을 복사하고 VM 옵션으로 포트를 다르게 주는 방식으로 했습니다.
예: -Dserver.port=19093

## 3) Order 인스턴스 1개 띄우기

* order-service 이름으로 Eureka에 등록
* FeignClient로 product-service를 호출
* Order endpoint로 들어오면 Product 호출 결과를 포함해서 응답

## 4) 확인

[http://localhost:19091/order/1](http://localhost:19091/order/1) 을 여러 번 호출하면
응답에 찍힌 Product 포트가 바뀌면서 라운드 로빈이 동작하는 걸 확인합니다.

---

## 실무 포인트

* 이 구조의 전제는 “서비스 디스커버리에서 인스턴스 목록을 얻는다” 입니다. 디스커버리가 흔들리면 로드밸런싱도 흔들립니다.
* Failover나 재시도는 편해 보이지만, 장애 상황에서 요청을 더 쏟아붓는 결과가 될 수 있어서 운영에서는 설정을 신중하게 가져가는 편입니다.
* 실습에서는 포트로 눈에 보이게 확인했는데, 실제로는 로그(traceId)나 메트릭으로 “어느 인스턴스가 처리했는지”를 추적하는 식으로 확인합니다.

---

## 용어 정리

| 용어             | 의미                         |
| -------------- | -------------------------- |
| Load Balancing | 트래픽을 여러 서버로 분산하는 방식        |
| Client-side LB | 호출하는 쪽이 인스턴스를 선택하는 방식      |
| Server-side LB | 앞단 장비/게이트웨이가 인스턴스를 선택하는 방식 |
| FeignClient    | 인터페이스 기반 선언적 HTTP 클라이언트    |
| Ribbon         | 클라이언트 사이드 로드밸런서            |
| Round Robin    | 순서대로 분배하는 알고리즘             |
| Failover       | 실패 시 다른 인스턴스로 전환하는 처리      |

---

## 공부하면서 떠올릴 질문

* Order가 product-service 인스턴스 목록을 “언제” 가져오고, “얼마나 자주” 갱신할까?
* 인스턴스가 하나 죽었을 때, 그 정보가 호출 쪽에 반영되기까지는 어떤 과정이 있을까?
* 재시도를 켜면 편해지는데, 어떤 상황에서 장애를 더 키울 수도 있을까?
* 서버 사이드 로드 밸런싱(L7)과 같이 쓸 때는 역할을 어떻게 나누는 게 자연스러울까?
