# service_discovery_eureka.md

## 개요

서비스 디스커버리는 MSA에서 “서비스 주소를 동적으로 관리하고 찾아주는 역할”입니다.
서비스가 늘고 줄면서 IP/포트가 바뀌어도, 서로를 안정적으로 호출할 수 있게 해줍니다.

핵심은 이거예요.

* 서비스는 등록 서버에 자기 주소를 등록한다
* 다른 서비스는 등록 서버에서 주소를 조회해서 호출한다
* 살아있는 인스턴스만 남기려고 헬스 체크를 한다

---

## 서비스 디스커버리가 필요한 이유

MSA에서는 서비스 인스턴스가 자주 바뀝니다. (오토스케일링, 재시작, 배포 등)
이때 서비스 주소를 코드나 설정에 고정해두면 운영에서 바로 터집니다.

그래서 “주소를 직접 관리하지 말고, 중앙에서 조회해서 쓰자”가 서비스 디스커버리입니다.

---

## Eureka 개요

Eureka는 넷플릭스가 만든 서비스 디스커버리(레지스트리) 서버입니다.

* 중앙 저장소 역할
  여러 서비스 인스턴스의 위치를 보관합니다.
* 상태 관리(가용성)
  인스턴스가 살아있는지 주기적으로 확인합니다.
* 고가용성 지원
  Eureka 서버 자체도 여러 대를 클러스터로 구성할 수 있습니다.

---

## Eureka 구성 요소

Eureka는 크게 서버/클라이언트로 나뉩니다.

* Eureka Server
  서비스 등록 정보를 들고 있는 레지스트리 서버
* Eureka Client
  각 서비스 애플리케이션(자기 자신을 등록하고, 다른 서비스 목록도 조회)

---

## Eureka 서버 설정 포인트

강의에서 나온 서버 설정에서 중요한 의도는 이거예요.

* 서버는 보통 “자기 자신을 등록하지 않는다”
  register-with-eureka=false
* 서버는 보통 “레지스트리를 다른 데서 안 가져온다”
  fetch-registry=false
* enable-self-preservation 같은 옵션은 운영에서는 조심해야 함
  강의에서는 false로 두지만, 실제 운영에서는 네트워크 흔들림 때문에 정상 인스턴스가 대량으로 빠지는 문제가 생길 수도 있습니다.
  (지금 단계에서는 “이런 모드가 있다” 정도로만 알고 있으면 충분)

---

## Eureka 클라이언트 설정 포인트

클라이언트는 의존성 추가하고 application name만 있으면 기본 등록 흐름이 됩니다.
추가로 설정에서 자주 보는 값들은 아래 의미예요.

* defaultZone
  Eureka 서버 주소
* register-with-eureka / fetch-registry
  등록할지, 목록을 받아올지
* lease-renewal-interval / lease-expiration-duration
  하트비트 갱신 주기와 만료 기준
  갱신이 끊기면 “죽었다고 판단”해서 레지스트리에서 제외될 수 있습니다.
* prefer-ip-address
  호스트명 대신 IP 기반 등록을 선호하는 옵션

---

## 서비스 등록과 조회 흐름(전체 그림)

정리하면 흐름은 이렇게 굴러갑니다.

1. 서비스 실행
2. Eureka 서버에 자기 인스턴스 정보 등록
3. Eureka 서버는 목록을 유지하고 헬스 체크/리스 만료로 상태를 정리
4. 다른 서비스(또는 게이트웨이)가 Eureka에서 대상 서비스 목록 조회
5. 로드밸런서가 인스턴스를 하나 골라 호출

여기서 중요한 건 “조회하는 쪽은 서비스의 실제 주소를 모르고, 서비스 이름으로 호출한다”는 점입니다.

---

## 호출 예시(강의 기준)

강의에서는 두 가지 방식으로 설명했어요.

## 1) RestTemplate + @LoadBalanced

* @LoadBalanced 를 붙이면, URL에 서비스 이름을 넣었을 때 Eureka에서 실제 인스턴스로 바꿔서 호출합니다.
* 예: [http://my-service/api/data](http://my-service/api/data) 처럼 이름 기반 호출

이 방식은 “동작 원리 이해”에는 좋고, 실무에서는 Feign이 더 많이 쓰이는 편입니다.

## 2) FeignClient

* 인터페이스에 name="my-service"만 주면, 내부적으로 서비스 조회/호출을 더 깔끔하게 처리합니다.
* 코드가 훨씬 간단해지고, 호출 정의가 정리되는 장점이 있습니다.

---

## 헬스 체크와 장애 처리

* 기본 헬스 체크는 /actuator/health 같은 엔드포인트를 기반으로 하기도 합니다.
* 장애가 감지되거나 리스 갱신이 끊기면, Eureka가 해당 인스턴스를 레지스트리에서 제외합니다.
* 그러면 다른 서비스가 조회할 때 그 인스턴스는 후보에서 빠져서 호출되지 않습니다.

---

## Eureka 고가용성(클러스터)

Eureka 서버도 하나만 두면 불안하니, 여러 대로 구성할 수 있습니다.

* 여러 Eureka 서버가 서로를 peer로 등록
* 각자 레지스트리를 공유/백업하는 구조로 고가용성을 확보

설정에서 defaultZone에 여러 서버 주소를 나열하는 방식이 대표적입니다.

---

## 실습 요약(강의 흐름)

강의 실습은 “Eureka 서버 1대에 서비스 인스턴스 2개를 붙여보기”였습니다.

* Eureka Server 실행 (예: 19090)
* Service instance 1 실행 (예: 19091)
* Service instance 2 실행 (예: 19092)
* Eureka 대시보드(서버 주소)로 들어가서 두 인스턴스가 등록된 걸 확인

---

## 실무 포인트(너무 깊지 않게)

* 서비스 디스커버리는 “주소 문제를 해결”하는 도구고, 이것만으로 장애가 끝나는 건 아닙니다.
  호출 쪽에서 로드밸런싱, 타임아웃, 재시도, 서킷브레이커 같은 정책이 같이 있어야 운영이 안정적입니다.
* lease 관련 값(갱신/만료)은 너무 공격적으로 잡으면 “살아있는 인스턴스가 빠졌다가 들어왔다가” 하는 흔들림이 생길 수 있습니다.
* 대시보드에서 보이는 등록 상태는 운영에서 1차 확인 용도로 도움이 됩니다.

---

## 용어 정리

| 용어                | 의미                               |
| ----------------- | -------------------------------- |
| Service Discovery | 서비스 위치를 동적으로 찾는 구조               |
| Registry          | 서비스 인스턴스 목록을 저장하는 곳              |
| Eureka Server     | 레지스트리를 제공하는 서버                   |
| Eureka Client     | 레지스트리에 등록하고, 목록을 조회하는 서비스        |
| Lease             | 하트비트 기반으로 살아있음을 유지하는 임대 개념       |
| Health Check      | 서비스 상태를 확인하는 방식                  |
| Peer              | Eureka 서버끼리 서로 등록해서 고가용성을 만드는 관계 |

---

## 공부하면서 떠올릴 질문

* 서비스 이름으로 호출할 때, 실제로 “어떤 인스턴스”로 갈지는 어디에서 결정될까?
* lease-renewal / expiration 값을 바꾸면 “장애 감지 속도”와 “오탐” 중 무엇이 더 민감해질까?
* Eureka 서버가 죽으면, 이미 떠 있는 서비스들은 호출을 계속 할 수 있을까? 아니면 전부 멈출까?
* RestTemplate 방식과 Feign 방식은 실무에서 어떤 기준으로 선택하는 게 좋을까?
